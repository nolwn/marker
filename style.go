package marker

import "fmt"

const esc = "\x1b"    // escape
const csi = esc + "[" // control sequence introducer

type colorCode int8
type effectCode int8

// Styles and Reset
const (
	StyleReset effectCode = iota
	Bold
	Dim
	Italic
	Underline
	Blinking
	_
	Inverse
	Hidden
	Strikethrough
)

// Color number values. These correspond to the foreground colors, but can be made into
// background colors just by adding 10 which is done automatically by the Background
// method.
const (
	Black colorCode = iota + 30
	Red
	Green
	Yellow
	Blue
	Magenta
	Cyan
	White
	_
	Default // Default resets colors
)

// Bright color number values. These correspond to the foreground colors, but can be
// made into background colors just by adding 10 which is done automatically by the
// Background method.
const (
	BrtBlack colorCode = iota + Black + 60
	BrtRed
	BrtGreen
	BrtYellow
	BrtBlue
	BrtMagenta
	BrtCyan
	BrtWhite
)

type style struct {
	background colorCode
	color      colorCode
	effect     effectCode
}

// Style returns a style type that can be used to generate ansi escape codes. The style
// type implements fmt.Stringer, which will returns the ansi code that was constructed.
func Style() *style {
	return &style{}
}

// Color take a color value and sets it as the color of the text. The color value is
// expected to correspond to the actual escape code value for that color and, since
// no one wants to have to remember that, the programmer is expected to use one of the
// provided const values.
//
// If a value falls outside of the expected range, nothing will be set and the passed
// value will be ignored.
func (s *style) Color(c colorCode) *style {
	if c >= Black && c <= White {
		s.color = c
	} else if c >= BrtBlack && c <= BrtWhite {
		s.color = c
	} else if c == Default {
		s.color = c
	}

	return s
}

// Background takes a color value and sets it as the color of the text. The color value
// is expected to correspond to the actual escape code value for that color as a
// foreground color. Background will convert that value to a background color
// automatically. Since no one wants to have to remember those values, the programmer is
// expected to use one of the provided const values.
//
// If a value falls outside of the expected range, nothing will be set and the passed
// value will be ignored.
func (s *style) Background(c colorCode) *style {
	var offset colorCode = 10
	if c >= Black && c <= White {
		s.background = c + offset
	} else if c >= BrtBlack && c <= BrtWhite {
		s.background = c + offset
	} else if s.color == Default {
		s.background = c + offset
	}

	return s
}

// Effect takes an effect value and sets it as the text effect. The effect value is
// expected to correspond to the actual escape cade value for that effect. Since no one
// wants to remember those values, the programmer is expected to use one of the provided
// const values.
//
// If a value falls outside of the expected range, nothing will be set and the passed
// value will be ignored.
func (s *style) Effect(e effectCode) *style {

	// between Reset and Strikethrough, but not 6 (since that value's skipped)
	if e >= Bold && e <= Strikethrough && e != 6 {
		s.effect = e
	}

	return s
}

// String satisfies the fmt.Stringer method and allows the style type to be passed as a
// string to fmt function. The resulting string will be the escape code value that was
// generated by previous method calls.
func (s *style) String() string {
	codes := ""

	if s.background != 0 {
		codes = appendCode(codes, fmt.Sprint(s.background))
	}

	if s.color != 0 {
		codes = appendCode(codes, fmt.Sprint(s.color))
	}

	if s.effect != 0 {
		codes = appendCode(codes, fmt.Sprint(s.effect))
	}

	return fmt.Sprintf("%s%sm", csi, codes)
}

// Write takes a string and returns a new string which is the string that was passed
// wrapped in the current code and a reset.
func (s *style) Write(str string) string {
	code := s.String()
	return fmt.Sprintf("%s%s%s", code, str, Reset())
}

// Reset returns the code to reset all styles
func Reset() string {
	return fmt.Sprintf("%s%dm", csi, StyleReset)
}

// appendCode takes a string of code(s) separated by ;'s and another code and appends it
// with a ; separating it.
func appendCode(codes string, code string) string {
	if len(codes) == 0 {
		return code
	} else {
		return fmt.Sprintf("%s;%s", codes, code)
	}
}
